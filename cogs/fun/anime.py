"""
Module de gestion des articles anime pour Hermes Bot

Ce module g√®re la r√©cup√©ration, le filtrage et l'envoi automatique d'articles anime
depuis Animotaku.fr vers Discord. Il inclut un syst√®me de cache pour √©viter les doublons
et des commandes de gestion pour les administrateurs.

Fonctionnalit√©s:
- R√©cup√©ration automatique d'articles depuis Animotaku.fr
- Filtrage des articles par date (articles d'hier)
- Syst√®me de cache pour √©viter les doublons
- Envoi automatique dans un canal Discord configur√©
- Commandes de gestion et de statut
- Gestion des couleurs dominantes des images

Auteur: Dr.TableBasse
Version: 2.0
"""

import requests
import discord
from discord import app_commands
from discord.ext import commands, tasks
from bs4 import BeautifulSoup
from datetime import datetime, timedelta
from PIL import Image
from io import BytesIO
from collections import Counter
import os
from dotenv import load_dotenv
import json
import hashlib
import sys
import asyncio
from utils.command_manager import CommandStatusManager, command_enabled
import logging
from utils.logging import log_command
import aiohttp

# Ajouter le r√©pertoire parent au path pour les imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

# Charger les variables d'environnement
load_dotenv()

# Cache pour √©viter les doublons d'articles
SENT_ARTICLES_CACHE = set()
CACHE_FILE = "sent_articles_cache.json"

logger = logging.getLogger("fun_commands")

def load_sent_articles_cache():
    """
    Charge le cache des articles d√©j√† envoy√©s depuis le fichier JSON.
    
    Returns:
        None: Met √† jour la variable globale SENT_ARTICLES_CACHE
    """
    global SENT_ARTICLES_CACHE
    try:
        if os.path.exists(CACHE_FILE):
            with open(CACHE_FILE, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
                SENT_ARTICLES_CACHE = set(cache_data.get('sent_articles', []))
                print(f"üìã Cache charg√©: {len(SENT_ARTICLES_CACHE)} articles d√©j√† envoy√©s")
        else:
            SENT_ARTICLES_CACHE = set()
            print("üìã Cache initialis√© (fichier inexistant)")
    except Exception as e:
        print(f"‚ùå Erreur lors du chargement du cache: {e}")
        SENT_ARTICLES_CACHE = set()

def save_sent_articles_cache():
    """
    Sauvegarde le cache des articles envoy√©s dans le fichier JSON.
    
    Returns:
        None: Sauvegarde la variable globale SENT_ARTICLES_CACHE
    """
    try:
        cache_data = {
            'sent_articles': list(SENT_ARTICLES_CACHE),
            'last_updated': datetime.now().isoformat()
        }
        with open(CACHE_FILE, 'w', encoding='utf-8') as f:
            json.dump(cache_data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"‚ùå Erreur lors de la sauvegarde du cache: {e}")

def get_article_hash(title, link, date):
    """
    G√©n√®re un hash unique pour un article bas√© sur son titre, lien et date.
    
    Args:
        title (str): Titre de l'article
        link (str): Lien de l'article
        date (str): Date de l'article
        
    Returns:
        str: Hash unique de l'article
    """
    content = f"{title}{link}{date}"
    return hashlib.md5(content.encode()).hexdigest()

def is_article_sent(article_hash):
    """
    V√©rifie si un article a d√©j√† √©t√© envoy√© en utilisant son hash.
    
    Args:
        article_hash (str): Hash unique de l'article
        
    Returns:
        bool: True si l'article a d√©j√† √©t√© envoy√©, False sinon
    """
    return article_hash in SENT_ARTICLES_CACHE

def mark_article_as_sent(article_hash):
    """
    Marque un article comme envoy√© en ajoutant son hash au cache.
    
    Args:
        article_hash (str): Hash unique de l'article
        
    Returns:
        None: Met √† jour le cache et sauvegarde
    """
    SENT_ARTICLES_CACHE.add(article_hash)
    save_sent_articles_cache()

def cleanup_old_cache():
    """
    Nettoie le cache en supprimant les anciens articles (plus de 7 jours).
    
    Returns:
        None: Met √† jour le cache
    """
    try:
        if os.path.exists(CACHE_FILE):
            with open(CACHE_FILE, 'r', encoding='utf-8') as f:
                cache_data = json.load(f)
            
            # Supprimer les articles plus anciens que 7 jours
            cutoff_date = datetime.now() - timedelta(days=7)
            old_articles = []
            
            for article_hash in SENT_ARTICLES_CACHE:
                # Pour simplifier, on supprime les articles bas√©s sur leur hash
                # En pratique, on pourrait stocker la date avec chaque hash
                old_articles.append(article_hash)
            
            # Supprimer 20% des articles les plus anciens
            if len(old_articles) > 50:
                articles_to_remove = old_articles[:len(old_articles) // 5]
                SENT_ARTICLES_CACHE.difference_update(articles_to_remove)
                save_sent_articles_cache()
                print(f"üßπ Cache nettoy√©: {len(articles_to_remove)} articles supprim√©s")
    except Exception as e:
        print(f"‚ùå Erreur lors du nettoyage du cache: {e}")

# Charger le cache au d√©marrage
load_sent_articles_cache()
cleanup_old_cache()

def get_dominant_color(image_url):
    """
    R√©cup√®re la couleur dominante d'une image via son URL.
    Merci GPT
    """
    try:
        response = requests.get(image_url, timeout=10)
        response.raise_for_status()
        img = Image.open(BytesIO(response.content))

        # Redimensionne l'image pour acc√©l√©rer le processus (plus petite taille)
        img = img.resize((100, 100))

        # Convertir en mode RGB et r√©cup√©rer les couleurs
        img = img.convert('RGB')
        pixels = list(img.getdata())

        # Compter les couleurs et obtenir la couleur dominante
        color_counts = Counter(pixels)
        dominant_color = color_counts.most_common(1)[0][0]  # R√©cup√®re la couleur la plus fr√©quente
        return discord.Color.from_rgb(*dominant_color)  # Renvoie la couleur sous forme de discord.Color
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur lors de la r√©cup√©ration de la couleur dominante: {e}")
        return discord.Color.blue()

def get_articles():
    """Scrape les articles du site et retourne une liste (titre, lien, date, image)."""
    try:
        r = requests.get("https://animotaku.fr/actualite-manga-anime/", timeout=30)
        print(f"üì° Status code: {r.status_code}")
        soup = BeautifulSoup(r.text, "html.parser")
        articles = []

        containers = soup.find_all("div", class_="elementor-posts-container")

        for container in containers:
            for article in container.find_all("article", class_="elementor-post"):

                title_tag = article.find("h3", class_="elementor-post__title")
                title_link = title_tag.find("a") if title_tag else None
                title = title_link.text.strip() if title_link else "Titre non trouv√©"
                link = title_link["href"] if title_link else "Pas de lien"

                date_tag = article.find("span", class_="elementor-post-date")
                date = date_tag.text.strip() if date_tag else "Date non trouv√©e"

                thumbnail_tag = article.find("a", class_="elementor-post__thumbnail__link")
                img_tag = thumbnail_tag.find("img") if thumbnail_tag else None
                if img_tag:
                    thumbnail_url = img_tag.get("data-lazy-src", img_tag.get("src", "Pas d'image"))
                    if thumbnail_url.startswith("//"):
                        thumbnail_url = "https:" + thumbnail_url
                else:
                    thumbnail_url = "Pas d'image"

                articles.append((title, link, date, thumbnail_url))

        print(f"üì∞ {len(articles)} articles r√©cup√©r√©s depuis Animotaku.fr")
        return articles
    except Exception as e:
        print(f"‚ùå Erreur lors de la r√©cup√©ration des articles: {e}")
        return []

def filter_articles():
    """
    Filtre les articles pour ne garder que ceux d'hier.
    """
    MONTHS_EN_FR = {
        "January": "janvier",
        "February": "f√©vrier",
        "March": "mars",
        "April": "avril",
        "May": "mai",
        "June": "juin",
        "July": "juillet",
        "August": "ao√ªt",
        "September": "septembre",
        "October": "octobre",
        "November": "novembre",
        "December": "d√©cembre",
    }
    yesterday = datetime.now() - timedelta(days=1)
    day = yesterday.strftime("%d").lstrip("0")
    month_en = yesterday.strftime("%B")
    year = yesterday.strftime("%Y")

    month_fr = MONTHS_EN_FR[month_en]
    formatted_yesterday = f"{day} {month_fr} {year}"

    articles = get_articles()

    filtered_articles = [a for a in articles if a[2].strip().lower() == formatted_yesterday.lower()]
    print(f"üìÖ {len(filtered_articles)} articles d'hier trouv√©s")
    return filtered_articles

async def send_articles(bot, test_mode=False):
    """
    Envoie les articles anime dans le canal Discord configur√©.
    
    Args:
        bot: Instance du bot Discord
        test_mode (bool): Si True, r√©cup√®re tous les articles r√©cents au lieu de seulement ceux d'hier
        
    Returns:
        None
    """
    try:
        # R√©cup√©rer le canal anime depuis les variables d'environnement
        anime_channel_id = int(os.getenv('ANIME_NEWS_CHANNEL_ID', '1388804969129574500'))
        channel = bot.get_channel(anime_channel_id)
        
        if not channel:
            print(f"‚ùå Canal anime {anime_channel_id} non trouv√©")
            # Fallback vers le canal g√©n√©ral si le canal anime n'existe pas
            from utils.constants import BOT_CHANNEL_START
            channel = bot.get_channel(BOT_CHANNEL_START)
            if not channel:
                print(f"‚ùå Canal de fallback {BOT_CHANNEL_START} non trouv√©")
                return
            print(f"‚ö†Ô∏è Utilisation du canal de fallback: {BOT_CHANNEL_START}")

        if test_mode:
            print("üß™ Mode test activ√© - R√©cup√©ration de tous les articles r√©cents...")
            articles = get_articles()
            # Limiter √† 5 articles pour le test
            articles = articles[:5]
        else:
            articles = filter_articles()

        if not articles:
            print("‚è∞ [Anime] Aucun nouvel article √† envoyer lors de ce check.")
            return

        print(f"üì§ Envoi de {len(articles)} article(s) dans le canal anime")
        
        ignored_count = 0
        for i, (title, link, date, thumbnail_url) in enumerate(articles, 1):
            # G√©n√©rer un hash unique pour cet article
            article_hash = get_article_hash(title, link, date)
            
            # V√©rifier si l'article a d√©j√† √©t√© envoy√©
            if is_article_sent(article_hash):
                print(f"‚è≠Ô∏è  Article {i}/{len(articles)} ignor√© (d√©j√† envoy√©): {title[:50]}...")
                ignored_count += 1
                continue
            
            try:
                # D√©tecter le type d'article
                ANIME_DETECTOR = ["anime", "√©pisode", "episode", "√©pisodes", "episodes"]
                info = "Anime" if any(dec in title.lower() for dec in ANIME_DETECTOR) else "Manga" if "manga" in title.lower() else "News"
                
                # Cr√©er l'embed
                embed = discord.Embed(
                    title=f"{info} News !",
                    description=title,
                    url=link,
                    color=discord.Color.blue()
                )
                
                # Ajouter l'image principale si disponible
                if thumbnail_url and thumbnail_url != "Pas d'image":
                    try:
                        embed.set_image(url=thumbnail_url)
                        # R√©cup√©rer la couleur dominante
                        try:
                            dominant_color = get_dominant_color(thumbnail_url)
                            embed.color = dominant_color
                        except:
                            pass
                        print(f"‚úÖ Image de l'article utilis√©e: {thumbnail_url[:50]}...")
                    except Exception as img_error:
                        print(f"‚ö†Ô∏è Erreur avec l'image de l'article {i}: {img_error}")
                
                # Ajouter le thumbnail (logo Hermes)
                embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/1027875503144701952/1337007021618364476/2c8e477cf2875f06776c14b5f112e90a.png?ex=67a5e052&is=67a48ed2&hm=8c6dc97b68fa7fa11a765e0bae71434650927b50e2c4e7dee5fef72a23c54bec&")
                
                # Ajouter l'auteur
                embed.set_author(
                    name="Hermes Bot",
                    url="https://github.com/DrTableBasse/Hermes/",
                    icon_url="https://avatars.githubusercontent.com/u/63105226?v=4"
                )
                
                # Ajouter le footer
                embed.set_footer(text=f"üì∞ Date de publication : {date} ‚Ä¢ Source: Animotaku.fr ‚Ä¢ üéå News Anime")
                
                # Envoyer l'embed
                await channel.send(embed=embed)
                
                # Marquer l'article comme envoy√©
                mark_article_as_sent(article_hash)
                
                print(f"‚úÖ Article {i}/{len(articles)} envoy√©: {title[:50]}...")
                
                # Petite pause pour √©viter le rate limiting
                await asyncio.sleep(1)
                
            except Exception as e:
                print(f"‚ùå Erreur lors de l'envoi de l'article {i}: {e}")
        
        if ignored_count > 0:
            print(f"üìä R√©sum√©: {ignored_count} article(s) ignor√©(s) (d√©j√† envoy√©s)")
            
    except Exception as e:
        print(f"‚ùå Erreur lors de l'envoi des articles: {e}")

class Anime(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.anime_check.start()
        print("‚úÖ Module Anime charg√©")

    def cog_unload(self):
        self.anime_check.cancel()

    @tasks.loop(hours=1)  # V√©rification toutes les heures
    async def anime_check(self):
        """V√©rifie et envoie les nouveaux articles anime"""
        await send_articles(self.bot)

    @anime_check.before_loop
    async def before_anime_check(self):
        """Attend que le bot soit pr√™t avant de commencer les v√©rifications"""
        await self.bot.wait_until_ready()
        print("üéå Bot pr√™t - V√©rification des articles anime activ√©e")

async def setup(bot):
    await bot.add_cog(Anime(bot))
